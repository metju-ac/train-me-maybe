/*
RegioJet's Affiliate API Reference

The RegioJet\\'s Affiliate API is a set of endpoints that help your application integrate with RegioJet.  The API is organized arount [REST](https://en.wikipedia.org/wiki/Representational_state_transfer). Our API uses standard HTTP methods, authentication, and status codes.  # Authentication Authentication to the API is performed via [HTTP Basic Auth](https://en.wikipedia.org/wiki/Basic_access_authentication) for all endpoints listed in this documentation with the exception of `/users/authenticate`, which uses bearer token.  API requests without authentication will fail.  All API requests must be made over [HTTPS](https://en.wikipedia.org/wiki/HTTPS).  # Errors  RegioJet uses conventional HTTP status codes in responses to indicate the success or failure of an API request.  In general:   * `2xx` codes indicate success;   * `4xx` codes indicate an error that failed given the information provided in request.   * `5xx` codes indicate an error with RegioJet's servers. 

API version: 1.1.0
Contact: developers@studentagency.cz
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// RoutesAPIService RoutesAPI service
type RoutesAPIService service

type ApiGetPassengersDataRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	routeId string
	filter *PassengersDataRequest
	xApplicationOrigin *string
	xLang *string
	xCurrency *string
}

func (r ApiGetPassengersDataRequest) Filter(filter PassengersDataRequest) ApiGetPassengersDataRequest {
	r.filter = &filter
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiGetPassengersDataRequest) XApplicationOrigin(xApplicationOrigin string) ApiGetPassengersDataRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiGetPassengersDataRequest) XLang(xLang string) ApiGetPassengersDataRequest {
	r.xLang = &xLang
	return r
}

// A three-letter currency code from [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). Defines monetary unit to be used in respons.  Currently supported currencies:  | Currency     | ISO 4217 code | |--------------|---------------| | Czech koruna | CZK           | | Euro         | EUR           | 
func (r ApiGetPassengersDataRequest) XCurrency(xCurrency string) ApiGetPassengersDataRequest {
	r.xCurrency = &xCurrency
	return r
}

func (r ApiGetPassengersDataRequest) Execute() (*PassengersDataResponse, *http.Response, error) {
	return r.ApiService.GetPassengersDataExecute(r)
}

/*
GetPassengersData Get mandatory passengers data.

Retuns separately data of the first passenger and data of other passengers for the given route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param routeId Unique identifier for the route. It consists of route section identifiers separed by commas (e.g. `section0.id,section1.id,section2.id`).
 @return ApiGetPassengersDataRequest
*/
func (a *RoutesAPIService) GetPassengersData(ctx context.Context, routeId string) ApiGetPassengersDataRequest {
	return ApiGetPassengersDataRequest{
		ApiService: a,
		ctx: ctx,
		routeId: routeId,
	}
}

// Execute executes the request
//  @return PassengersDataResponse
func (a *RoutesAPIService) GetPassengersDataExecute(r ApiGetPassengersDataRequest) (*PassengersDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PassengersDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.GetPassengersData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeId}/passengersData"
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(parameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.filter == nil {
		return localVarReturnValue, nil, reportError("filter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	if r.xCurrency != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Currency", r.xCurrency, "", "")
	}
	// body params
	localVarPostBody = r.filter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse4004
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRouteFreeSeatsRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	request *RouteSeatsRequest
	xApplicationOrigin *string
	xLang *string
	xOccupied *bool
}

// Descriptions of the Route detail
func (r ApiGetRouteFreeSeatsRequest) Request(request RouteSeatsRequest) ApiGetRouteFreeSeatsRequest {
	r.request = &request
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiGetRouteFreeSeatsRequest) XApplicationOrigin(xApplicationOrigin string) ApiGetRouteFreeSeatsRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiGetRouteFreeSeatsRequest) XLang(xLang string) ApiGetRouteFreeSeatsRequest {
	r.xLang = &xLang
	return r
}

// Return occupied seats. To turn off have to be deactivated at administrative app and X-occupied have to be false. Default value is false.
func (r ApiGetRouteFreeSeatsRequest) XOccupied(xOccupied bool) ApiGetRouteFreeSeatsRequest {
	r.xOccupied = &xOccupied
	return r
}

func (r ApiGetRouteFreeSeatsRequest) Execute() (*RouteSeatsResponse, *http.Response, error) {
	return r.ApiService.GetRouteFreeSeatsExecute(r)
}

/*
GetRouteFreeSeats Get route tandem free seats grouped by vehicles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRouteFreeSeatsRequest
*/
func (a *RoutesAPIService) GetRouteFreeSeats(ctx context.Context) ApiGetRouteFreeSeatsRequest {
	return ApiGetRouteFreeSeatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RouteSeatsResponse
func (a *RoutesAPIService) GetRouteFreeSeatsExecute(r ApiGetRouteFreeSeatsRequest) (*RouteSeatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteSeatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.GetRouteFreeSeats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/freeSeats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	if r.xOccupied != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Occupied", r.xOccupied, "", "")
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRouteFreeSeats110Request struct {
	ctx context.Context
	ApiService *RoutesAPIService
	routeId string
	request *RouteSeatsRequest
	xApplicationOrigin *string
	xLang *string
}

// Route section details.
func (r ApiGetRouteFreeSeats110Request) Request(request RouteSeatsRequest) ApiGetRouteFreeSeats110Request {
	r.request = &request
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiGetRouteFreeSeats110Request) XApplicationOrigin(xApplicationOrigin string) ApiGetRouteFreeSeats110Request {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiGetRouteFreeSeats110Request) XLang(xLang string) ApiGetRouteFreeSeats110Request {
	r.xLang = &xLang
	return r
}

func (r ApiGetRouteFreeSeats110Request) Execute() (*RouteSeatsResponse110, *http.Response, error) {
	return r.ApiService.GetRouteFreeSeats110Execute(r)
}

/*
GetRouteFreeSeats110 Get list of free seats.

Returns detailed data about all free seats available for reservation. Free seats are grouped by vehicle.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param routeId Unique identifier for the route. It consists of route section identifiers separed by commas (e.g. `section0.id,section1.id,section2.id`).
 @return ApiGetRouteFreeSeats110Request

Deprecated
*/
func (a *RoutesAPIService) GetRouteFreeSeats110(ctx context.Context, routeId string) ApiGetRouteFreeSeats110Request {
	return ApiGetRouteFreeSeats110Request{
		ApiService: a,
		ctx: ctx,
		routeId: routeId,
	}
}

// Execute executes the request
//  @return RouteSeatsResponse110
// Deprecated
func (a *RoutesAPIService) GetRouteFreeSeats110Execute(r ApiGetRouteFreeSeats110Request) (*RouteSeatsResponse110, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RouteSeatsResponse110
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.GetRouteFreeSeats110")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeId}/freeSeats"
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(parameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.request == nil {
		return localVarReturnValue, nil, reportError("request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	// body params
	localVarPostBody = r.request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse4003
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimpleRouteDetailRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	routeId string
	fromStationId *int64
	toStationId *int64
	xApplicationOrigin *string
	xLang *string
	xCurrency *string
	tariffs *[]string
}

// Unique identifier for &#x60;from&#x60; station. Detailed data for identifier can be obtained from &#x60;/consts/locations&#x60; endpoint.
func (r ApiGetSimpleRouteDetailRequest) FromStationId(fromStationId int64) ApiGetSimpleRouteDetailRequest {
	r.fromStationId = &fromStationId
	return r
}

// Unique identifier for &#x60;from&#x60; station. Detailed data for identifier can be obtained from &#x60;/consts/locations&#x60; endpoint.
func (r ApiGetSimpleRouteDetailRequest) ToStationId(toStationId int64) ApiGetSimpleRouteDetailRequest {
	r.toStationId = &toStationId
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiGetSimpleRouteDetailRequest) XApplicationOrigin(xApplicationOrigin string) ApiGetSimpleRouteDetailRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiGetSimpleRouteDetailRequest) XLang(xLang string) ApiGetSimpleRouteDetailRequest {
	r.xLang = &xLang
	return r
}

// A three-letter currency code from [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). Defines monetary unit to be used in respons.  Currently supported currencies:  | Currency     | ISO 4217 code | |--------------|---------------| | Czech koruna | CZK           | | Euro         | EUR           | 
func (r ApiGetSimpleRouteDetailRequest) XCurrency(xCurrency string) ApiGetSimpleRouteDetailRequest {
	r.xCurrency = &xCurrency
	return r
}

// List of tariffs. Tariff keys can be obtained from &#x60;/consts/tariffs&#x60;. Multiple parameter instances should be used rather than multiple values when submitting multiple values. For example: &#x60;&amp;tariffs&#x3D;REGULAR&amp;tariffs&#x3D;ISIC&#x60;
func (r ApiGetSimpleRouteDetailRequest) Tariffs(tariffs []string) ApiGetSimpleRouteDetailRequest {
	r.tariffs = &tariffs
	return r
}

func (r ApiGetSimpleRouteDetailRequest) Execute() (*Route, *http.Response, error) {
	return r.ApiService.GetSimpleRouteDetailExecute(r)
}

/*
GetSimpleRouteDetail Get details of the given route.

Returns detailed data for the given route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param routeId Unique identifier for the route. It consists of route section identifiers separed by commas (e.g. `section0.id,section1.id,section2.id`).
 @return ApiGetSimpleRouteDetailRequest
*/
func (a *RoutesAPIService) GetSimpleRouteDetail(ctx context.Context, routeId string) ApiGetSimpleRouteDetailRequest {
	return ApiGetSimpleRouteDetailRequest{
		ApiService: a,
		ctx: ctx,
		routeId: routeId,
	}
}

// Execute executes the request
//  @return Route
func (a *RoutesAPIService) GetSimpleRouteDetailExecute(r ApiGetSimpleRouteDetailRequest) (*Route, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Route
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.GetSimpleRouteDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeId}/simple"
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(parameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromStationId == nil {
		return localVarReturnValue, nil, reportError("fromStationId is required and must be specified")
	}
	if r.toStationId == nil {
		return localVarReturnValue, nil, reportError("toStationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromStationId", r.fromStationId, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toStationId", r.toStationId, "", "")
	if r.tariffs != nil {
		t := *r.tariffs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tariffs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tariffs", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	if r.xCurrency != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Currency", r.xCurrency, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse4003
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSroPassengersDataRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	routeId string
	fromStationId *int64
	toStationId *int64
	xApplicationOrigin *string
	xCurrency *string
	xLang *string
	departureDate *time.Time
	seatClass *int32
	numberOfPassengers *int32
}

// Unique identifier for &#x60;from&#x60; station. Detailed data for identifier can be obtained from &#x60;/consts/locations&#x60; endpoint.
func (r ApiGetSroPassengersDataRequest) FromStationId(fromStationId int64) ApiGetSroPassengersDataRequest {
	r.fromStationId = &fromStationId
	return r
}

// Unique identifier for &#x60;from&#x60; station. Detailed data for identifier can be obtained from &#x60;/consts/locations&#x60; endpoint.
func (r ApiGetSroPassengersDataRequest) ToStationId(toStationId int64) ApiGetSroPassengersDataRequest {
	r.toStationId = &toStationId
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiGetSroPassengersDataRequest) XApplicationOrigin(xApplicationOrigin string) ApiGetSroPassengersDataRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A three-letter currency code from [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). Defines monetary unit to be used in respons.  Currently supported currencies:  | Currency     | ISO 4217 code | |--------------|---------------| | Czech koruna | CZK           | | Euro         | EUR           | 
func (r ApiGetSroPassengersDataRequest) XCurrency(xCurrency string) ApiGetSroPassengersDataRequest {
	r.xCurrency = &xCurrency
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiGetSroPassengersDataRequest) XLang(xLang string) ApiGetSroPassengersDataRequest {
	r.xLang = &xLang
	return r
}

// Date and time of departure. Date is required. Time is optional.
func (r ApiGetSroPassengersDataRequest) DepartureDate(departureDate time.Time) ApiGetSroPassengersDataRequest {
	r.departureDate = &departureDate
	return r
}

// Seat class.
func (r ApiGetSroPassengersDataRequest) SeatClass(seatClass int32) ApiGetSroPassengersDataRequest {
	r.seatClass = &seatClass
	return r
}

// Number of passengers.
func (r ApiGetSroPassengersDataRequest) NumberOfPassengers(numberOfPassengers int32) ApiGetSroPassengersDataRequest {
	r.numberOfPassengers = &numberOfPassengers
	return r
}

func (r ApiGetSroPassengersDataRequest) Execute() (*SroPassengersDataResponse, *http.Response, error) {
	return r.ApiService.GetSroPassengersDataExecute(r)
}

/*
GetSroPassengersData Get mandatory passengers data.

Get mandatory passenger data for the given route and available seat reservations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param routeId Unique identifier for the route. It consists of route section identifiers separed by commas (e.g. `section0.id,section1.id,section2.id`).
 @return ApiGetSroPassengersDataRequest
*/
func (a *RoutesAPIService) GetSroPassengersData(ctx context.Context, routeId string) ApiGetSroPassengersDataRequest {
	return ApiGetSroPassengersDataRequest{
		ApiService: a,
		ctx: ctx,
		routeId: routeId,
	}
}

// Execute executes the request
//  @return SroPassengersDataResponse
func (a *RoutesAPIService) GetSroPassengersDataExecute(r ApiGetSroPassengersDataRequest) (*SroPassengersDataResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SroPassengersDataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.GetSroPassengersData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeId}/passengersData/RJ_SRO"
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(parameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromStationId == nil {
		return localVarReturnValue, nil, reportError("fromStationId is required and must be specified")
	}
	if r.toStationId == nil {
		return localVarReturnValue, nil, reportError("toStationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromStationId", r.fromStationId, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toStationId", r.toStationId, "", "")
	if r.departureDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureDate", r.departureDate, "", "")
	}
	if r.seatClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seatClass", r.seatClass, "", "")
	} else {
		var defaultValue int32 = 2
		r.seatClass = &defaultValue
	}
	if r.numberOfPassengers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfPassengers", r.numberOfPassengers, "", "")
	} else {
		var defaultValue int32 = 1
		r.numberOfPassengers = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/1.1.0+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xCurrency != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Currency", r.xCurrency, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSroRoutePricesRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	routeId string
	fromStationId *int64
	toStationId *int64
	xApplicationOrigin *string
	xCurrency *string
	xLang *string
	departureDate *time.Time
	seatClass *int32
	numberOfPassengers *int32
}

// Unique identifier for &#x60;from&#x60; station. Detailed data for identifier can be obtained from &#x60;/consts/locations&#x60; endpoint.
func (r ApiGetSroRoutePricesRequest) FromStationId(fromStationId int64) ApiGetSroRoutePricesRequest {
	r.fromStationId = &fromStationId
	return r
}

// Unique identifier for &#x60;from&#x60; station. Detailed data for identifier can be obtained from &#x60;/consts/locations&#x60; endpoint.
func (r ApiGetSroRoutePricesRequest) ToStationId(toStationId int64) ApiGetSroRoutePricesRequest {
	r.toStationId = &toStationId
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiGetSroRoutePricesRequest) XApplicationOrigin(xApplicationOrigin string) ApiGetSroRoutePricesRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A three-letter currency code from [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). Defines monetary unit to be used in respons.  Currently supported currencies:  | Currency     | ISO 4217 code | |--------------|---------------| | Czech koruna | CZK           | | Euro         | EUR           | 
func (r ApiGetSroRoutePricesRequest) XCurrency(xCurrency string) ApiGetSroRoutePricesRequest {
	r.xCurrency = &xCurrency
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiGetSroRoutePricesRequest) XLang(xLang string) ApiGetSroRoutePricesRequest {
	r.xLang = &xLang
	return r
}

// Date and time of departure. Date is required. Time is optional.
func (r ApiGetSroRoutePricesRequest) DepartureDate(departureDate time.Time) ApiGetSroRoutePricesRequest {
	r.departureDate = &departureDate
	return r
}

// Seat class.
func (r ApiGetSroRoutePricesRequest) SeatClass(seatClass int32) ApiGetSroRoutePricesRequest {
	r.seatClass = &seatClass
	return r
}

// Number of passengers.
func (r ApiGetSroRoutePricesRequest) NumberOfPassengers(numberOfPassengers int32) ApiGetSroRoutePricesRequest {
	r.numberOfPassengers = &numberOfPassengers
	return r
}

func (r ApiGetSroRoutePricesRequest) Execute() (*SroRouteDetail, *http.Response, error) {
	return r.ApiService.GetSroRoutePricesExecute(r)
}

/*
GetSroRoutePrices Get route detail.

Get available prices for the given route and type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param routeId Unique identifier for the route. It consists of route section identifiers separed by commas (e.g. `section0.id,section1.id,section2.id`).
 @return ApiGetSroRoutePricesRequest
*/
func (a *RoutesAPIService) GetSroRoutePrices(ctx context.Context, routeId string) ApiGetSroRoutePricesRequest {
	return ApiGetSroRoutePricesRequest{
		ApiService: a,
		ctx: ctx,
		routeId: routeId,
	}
}

// Execute executes the request
//  @return SroRouteDetail
func (a *RoutesAPIService) GetSroRoutePricesExecute(r ApiGetSroRoutePricesRequest) (*SroRouteDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SroRouteDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.GetSroRoutePrices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{routeId}/prices/RJ_SRO"
	localVarPath = strings.Replace(localVarPath, "{"+"routeId"+"}", url.PathEscape(parameterValueToString(r.routeId, "routeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromStationId == nil {
		return localVarReturnValue, nil, reportError("fromStationId is required and must be specified")
	}
	if r.toStationId == nil {
		return localVarReturnValue, nil, reportError("toStationId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromStationId", r.fromStationId, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toStationId", r.toStationId, "", "")
	if r.departureDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureDate", r.departureDate, "", "")
	}
	if r.seatClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seatClass", r.seatClass, "", "")
	} else {
		var defaultValue int32 = 2
		r.seatClass = &defaultValue
	}
	if r.numberOfPassengers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfPassengers", r.numberOfPassengers, "", "")
	} else {
		var defaultValue int32 = 1
		r.numberOfPassengers = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xCurrency != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Currency", r.xCurrency, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ForbiddenResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchRoutesRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	fromLocationId *int64
	fromLocationType *string
	toLocationId *int64
	toLocationType *string
	xApplicationOrigin *string
	xLang *string
	xCurrency *string
	departureTime *time.Time
	tariffs *[]string
	actionPrice *string
}

func (r ApiSearchRoutesRequest) FromLocationId(fromLocationId int64) ApiSearchRoutesRequest {
	r.fromLocationId = &fromLocationId
	return r
}

func (r ApiSearchRoutesRequest) FromLocationType(fromLocationType string) ApiSearchRoutesRequest {
	r.fromLocationType = &fromLocationType
	return r
}

func (r ApiSearchRoutesRequest) ToLocationId(toLocationId int64) ApiSearchRoutesRequest {
	r.toLocationId = &toLocationId
	return r
}

func (r ApiSearchRoutesRequest) ToLocationType(toLocationType string) ApiSearchRoutesRequest {
	r.toLocationType = &toLocationType
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiSearchRoutesRequest) XApplicationOrigin(xApplicationOrigin string) ApiSearchRoutesRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiSearchRoutesRequest) XLang(xLang string) ApiSearchRoutesRequest {
	r.xLang = &xLang
	return r
}

// A three-letter currency code from [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). Defines monetary unit to be used in respons.  Currently supported currencies:  | Currency     | ISO 4217 code | |--------------|---------------| | Czech koruna | CZK           | | Euro         | EUR           | 
func (r ApiSearchRoutesRequest) XCurrency(xCurrency string) ApiSearchRoutesRequest {
	r.xCurrency = &xCurrency
	return r
}

// Departure date-time
func (r ApiSearchRoutesRequest) DepartureTime(departureTime time.Time) ApiSearchRoutesRequest {
	r.departureTime = &departureTime
	return r
}

// Ticket tariff
func (r ApiSearchRoutesRequest) Tariffs(tariffs []string) ApiSearchRoutesRequest {
	r.tariffs = &tariffs
	return r
}

// Code indication of a current marketing action. Filtres searched routes on current marketing action. List of all marketing action for current route included in endpoint /consts/actionPrices.
func (r ApiSearchRoutesRequest) ActionPrice(actionPrice string) ApiSearchRoutesRequest {
	r.actionPrice = &actionPrice
	return r
}

func (r ApiSearchRoutesRequest) Execute() (*SearchResult, *http.Response, error) {
	return r.ApiService.SearchRoutesExecute(r)
}

/*
SearchRoutes Get collection of all routes that satisfy specified search criteria for the route.

Authorization not required (filtres info bubbles)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchRoutesRequest
*/
func (a *RoutesAPIService) SearchRoutes(ctx context.Context) ApiSearchRoutesRequest {
	return ApiSearchRoutesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchResult
func (a *RoutesAPIService) SearchRoutesExecute(r ApiSearchRoutesRequest) (*SearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.SearchRoutes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromLocationId == nil {
		return localVarReturnValue, nil, reportError("fromLocationId is required and must be specified")
	}
	if r.fromLocationType == nil {
		return localVarReturnValue, nil, reportError("fromLocationType is required and must be specified")
	}
	if r.toLocationId == nil {
		return localVarReturnValue, nil, reportError("toLocationId is required and must be specified")
	}
	if r.toLocationType == nil {
		return localVarReturnValue, nil, reportError("toLocationType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromLocationId", r.fromLocationId, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromLocationType", r.fromLocationType, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toLocationId", r.toLocationId, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toLocationType", r.toLocationType, "", "")
	if r.departureTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureTime", r.departureTime, "", "")
	}
	if r.tariffs != nil {
		t := *r.tariffs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tariffs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tariffs", t, "form", "multi")
		}
	}
	if r.actionPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionPrice", r.actionPrice, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	if r.xCurrency != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Currency", r.xCurrency, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSR70RoutesRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	departure *time.Time
	connection int64
	fromLocation int64
	toLocation string
	ticketType string
	xApplicationOrigin *string
	xCurrency *string
	xLang *string
	seatClass *int32
	numberOfPassengers *int32
}

// Date and time of departure, mandatory for this request.
func (r ApiSearchSR70RoutesRequest) Departure(departure time.Time) ApiSearchSR70RoutesRequest {
	r.departure = &departure
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiSearchSR70RoutesRequest) XApplicationOrigin(xApplicationOrigin string) ApiSearchSR70RoutesRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A three-letter currency code from [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). Defines monetary unit to be used in respons.  Currently supported currencies:  | Currency     | ISO 4217 code | |--------------|---------------| | Czech koruna | CZK           | | Euro         | EUR           | 
func (r ApiSearchSR70RoutesRequest) XCurrency(xCurrency string) ApiSearchSR70RoutesRequest {
	r.xCurrency = &xCurrency
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiSearchSR70RoutesRequest) XLang(xLang string) ApiSearchSR70RoutesRequest {
	r.xLang = &xLang
	return r
}

// Seat class.
func (r ApiSearchSR70RoutesRequest) SeatClass(seatClass int32) ApiSearchSR70RoutesRequest {
	r.seatClass = &seatClass
	return r
}

// Number of passengers.
func (r ApiSearchSR70RoutesRequest) NumberOfPassengers(numberOfPassengers int32) ApiSearchSR70RoutesRequest {
	r.numberOfPassengers = &numberOfPassengers
	return r
}

func (r ApiSearchSR70RoutesRequest) Execute() ([]SroRoute, *http.Response, error) {
	return r.ApiService.SearchSR70RoutesExecute(r)
}

/*
SearchSR70Routes Search for available routes.

Search available routes with free seat reservations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param connection CIS connection identifier.
 @param fromLocation Departure station numeric identifier in the SR70 format.
 @param toLocation Arrival station numeric identifier in the SR70 format.
 @param ticketType Ticket type.
 @return ApiSearchSR70RoutesRequest
*/
func (a *RoutesAPIService) SearchSR70Routes(ctx context.Context, connection int64, fromLocation int64, toLocation string, ticketType string) ApiSearchSR70RoutesRequest {
	return ApiSearchSR70RoutesRequest{
		ApiService: a,
		ctx: ctx,
		connection: connection,
		fromLocation: fromLocation,
		toLocation: toLocation,
		ticketType: ticketType,
	}
}

// Execute executes the request
//  @return []SroRoute
func (a *RoutesAPIService) SearchSR70RoutesExecute(r ApiSearchSR70RoutesRequest) ([]SroRoute, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SroRoute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.SearchSR70Routes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/{connection}/{fromLocation}/{toLocation}/{ticketType}"
	localVarPath = strings.Replace(localVarPath, "{"+"connection"+"}", url.PathEscape(parameterValueToString(r.connection, "connection")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"fromLocation"+"}", url.PathEscape(parameterValueToString(r.fromLocation, "fromLocation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"toLocation"+"}", url.PathEscape(parameterValueToString(r.toLocation, "toLocation")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ticketType"+"}", url.PathEscape(parameterValueToString(r.ticketType, "ticketType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.departure == nil {
		return localVarReturnValue, nil, reportError("departure is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "departure", r.departure, "", "")
	if r.seatClass != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seatClass", r.seatClass, "", "")
	} else {
		var defaultValue int32 = 2
		r.seatClass = &defaultValue
	}
	if r.numberOfPassengers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfPassengers", r.numberOfPassengers, "", "")
	} else {
		var defaultValue int32 = 1
		r.numberOfPassengers = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xCurrency != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Currency", r.xCurrency, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v BadRequestResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ForbiddenResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSimpleSearchRoutesRequest struct {
	ctx context.Context
	ApiService *RoutesAPIService
	fromLocationId *int64
	fromLocationType *string
	toLocationId *int64
	toLocationType *string
	xApplicationOrigin *string
	xLang *string
	xCurrency *string
	xUsedDepartureFromDateTime *time.Time
	xUsedDepartureToDateTime *time.Time
	departureDate *string
	tariffs *[]string
	actionPrice *string
	move *string
}

// Unique identifier for &#x60;from&#x60; location. This identifier can be obtained from &#x60;/consts/locations&#x60; endpoint. Unique identifier of either city, or station, can be used.
func (r ApiSimpleSearchRoutesRequest) FromLocationId(fromLocationId int64) ApiSimpleSearchRoutesRequest {
	r.fromLocationId = &fromLocationId
	return r
}

// Location type of unique identifier used in query parameter &#x60;fromLocationId&#x60;.
func (r ApiSimpleSearchRoutesRequest) FromLocationType(fromLocationType string) ApiSimpleSearchRoutesRequest {
	r.fromLocationType = &fromLocationType
	return r
}

// Unique identifier for &#x60;to&#x60; location. This identifier can be obtained from &#x60;/consts/locations&#x60; endpoint. Unique identifier of either city, or station, can be used.
func (r ApiSimpleSearchRoutesRequest) ToLocationId(toLocationId int64) ApiSimpleSearchRoutesRequest {
	r.toLocationId = &toLocationId
	return r
}

// Location type of unique identifier used in query parameter &#x60;toLocationId&#x60;.
func (r ApiSimpleSearchRoutesRequest) ToLocationType(toLocationType string) ApiSimpleSearchRoutesRequest {
	r.toLocationType = &toLocationType
	return r
}

// Application origin - APP - Mobile application (Android / Apple) - AFF - Affiliate application which is managed by third party - CAT - Web application used to sell catering - DEV - Only for development and testing - DOT - Check-in application for ticket sales on a train or bus - NOT - Unknown application type
func (r ApiSimpleSearchRoutesRequest) XApplicationOrigin(xApplicationOrigin string) ApiSimpleSearchRoutesRequest {
	r.xApplicationOrigin = &xApplicationOrigin
	return r
}

// A two-letter language code from [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes). Defines the language into which the response will be translated.  Currently supported languages:  | ISO language name | ISO 639-1 code | |-------------------|----------------| | Czech             | cs             | | German            | de             | | English           | en             | | Spanish           | es             | | French            | fr             | | Hungarian         | hu             | | Russian           | ru             | | Slovak            | sk             | | Ukrainian         | uk             | | Chinese           | zh             | 
func (r ApiSimpleSearchRoutesRequest) XLang(xLang string) ApiSimpleSearchRoutesRequest {
	r.xLang = &xLang
	return r
}

// A three-letter currency code from [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217). Defines monetary unit to be used in respons.  Currently supported currencies:  | Currency     | ISO 4217 code | |--------------|---------------| | Czech koruna | CZK           | | Euro         | EUR           | 
func (r ApiSimpleSearchRoutesRequest) XCurrency(xCurrency string) ApiSimpleSearchRoutesRequest {
	r.xCurrency = &xCurrency
	return r
}

// Should contain &#x60;date-time&#x60; value from previous route search. Its value is returned in response header of the same name. Used to move forward or backward in search results (i.e. for pagination).
func (r ApiSimpleSearchRoutesRequest) XUsedDepartureFromDateTime(xUsedDepartureFromDateTime time.Time) ApiSimpleSearchRoutesRequest {
	r.xUsedDepartureFromDateTime = &xUsedDepartureFromDateTime
	return r
}

// Should contain &#x60;date-time&#x60; value from previous route search. Its value is returned in response header of the same name. Used to move forward or backward in search results (i.e. for pagination).
func (r ApiSimpleSearchRoutesRequest) XUsedDepartureToDateTime(xUsedDepartureToDateTime time.Time) ApiSimpleSearchRoutesRequest {
	r.xUsedDepartureToDateTime = &xUsedDepartureToDateTime
	return r
}

// Departure date.
func (r ApiSimpleSearchRoutesRequest) DepartureDate(departureDate string) ApiSimpleSearchRoutesRequest {
	r.departureDate = &departureDate
	return r
}

// List of tariffs. Tariff keys can be obtained from &#x60;/consts/tariffs&#x60;. Multiple parameter instances should be used rather than multiple values when submitting multiple values. For example: &#x60;&amp;tariffs&#x3D;REGULAR&amp;tariffs&#x3D;ISIC&#x60;
func (r ApiSimpleSearchRoutesRequest) Tariffs(tariffs []string) ApiSimpleSearchRoutesRequest {
	r.tariffs = &tariffs
	return r
}

// Code indentifier of a marketing action. Filters search result based on applicability of provided marketing action to a route. List of all marketing actions for current route can be obtained from endpoint &#x60;/consts/actionPrices&#x60;.
func (r ApiSimpleSearchRoutesRequest) ActionPrice(actionPrice string) ApiSimpleSearchRoutesRequest {
	r.actionPrice = &actionPrice
	return r
}

// Move forward or backward in search results. Defines if next call to this endpoint will return next or previous result page.
func (r ApiSimpleSearchRoutesRequest) Move(move string) ApiSimpleSearchRoutesRequest {
	r.move = &move
	return r
}

func (r ApiSimpleSearchRoutesRequest) Execute() (*SimpleRouteSearchResult, *http.Response, error) {
	return r.ApiService.SimpleSearchRoutesExecute(r)
}

/*
SimpleSearchRoutes Search for routes that satisfy specified search criteria.

Get collection of all routes that satisfy specified search criteria for the route.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSimpleSearchRoutesRequest
*/
func (a *RoutesAPIService) SimpleSearchRoutes(ctx context.Context) ApiSimpleSearchRoutesRequest {
	return ApiSimpleSearchRoutesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimpleRouteSearchResult
func (a *RoutesAPIService) SimpleSearchRoutesExecute(r ApiSimpleSearchRoutesRequest) (*SimpleRouteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleRouteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RoutesAPIService.SimpleSearchRoutes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/routes/search/simple"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromLocationId == nil {
		return localVarReturnValue, nil, reportError("fromLocationId is required and must be specified")
	}
	if r.fromLocationType == nil {
		return localVarReturnValue, nil, reportError("fromLocationType is required and must be specified")
	}
	if r.toLocationId == nil {
		return localVarReturnValue, nil, reportError("toLocationId is required and must be specified")
	}
	if r.toLocationType == nil {
		return localVarReturnValue, nil, reportError("toLocationType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fromLocationId", r.fromLocationId, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "fromLocationType", r.fromLocationType, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toLocationId", r.toLocationId, "", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "toLocationType", r.toLocationType, "", "")
	if r.departureDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "departureDate", r.departureDate, "", "")
	}
	if r.tariffs != nil {
		t := *r.tariffs
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tariffs", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tariffs", t, "form", "multi")
		}
	}
	if r.actionPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actionPrice", r.actionPrice, "", "")
	}
	if r.move != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "move", r.move, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xApplicationOrigin != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Application-Origin", r.xApplicationOrigin, "", "")
	}
	if r.xLang != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Lang", r.xLang, "", "")
	}
	if r.xCurrency != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Currency", r.xCurrency, "", "")
	}
	if r.xUsedDepartureFromDateTime != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Used-DepartureFromDateTime", r.xUsedDepartureFromDateTime, "", "")
	}
	if r.xUsedDepartureToDateTime != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Used-DepartureToDateTime", r.xUsedDepartureToDateTime, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InlineResponse4002
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v UnauthorizedResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
